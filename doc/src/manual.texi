\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename manual.info
@settitle OpenDarkEngine Developer's Manual
@c %**end of header

@copying
This manual is for openDarkEngine (version @value{VERSION}, @value{UPDATED})

Copyright @copyright{} 2005-2006 OpenDarkEngine team.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''
@end quotation
@end copying

@titlepage
@title Sample Title
    
@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
     
@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top
@top OpenDarkEngine Developer's Manual
     
This is the main developer's manual for OpenDarkEngine
@end ifnottex
     
@menu
* Introduction::      Introduction to the manual
* Core architecture:: The core architecture of the engine
* Services::          The available services
@c Not used roght now - * Index::             Complete index.
@end menu


@c --------------------------------------------------------------------
@node Introduction
@chapter Introduction
@cindex Introduction

You have just started reading the developers manual for OpenDarkEngine project. The aim of this document is
to give you some insight about the project's architecture, enable you to quickly orient in the project's source
code.

@cindex Used technologies
@section Used technologies
The core of OpenDarkEngine written in C++, various other parts are planned or already written in python. Build system
used is CMake. Libraries currently used are OGRE, FreeImage.

@c --------------------------------------------------------------------
@node Core architecture
@chapter Core architecture
@cindex Core architecture

Whole engine exists in the Opde namespace. That means that every class definition, as well as typedef or enumeration,
all these things are defined within the Opde namespace, and either prefixed with 'Opde::', or imported via using keyword
when referenced from outside of this namespace.

@cindex shared_ptr
Throughout the source code, some of the instances are held in memory - their lifetime is controled - by shared_ptr class.
This class is very simmilar to the Boost's shared_ptr. The instances held by this smart pointer wrapper are easily identified
thanks to the typedefs used to distribute them - all those types are postfixed with 'Ptr' string (e.g. 'ServicePtr').

@cindex Callbacks
Also worth mentioning is extensive use of the listener approach and factory approach. Classes can expose different message types, 
which other register to, and then receive the message whenever the source class has something to tell. See the MessageSource.h and 
Callback.h files in src/base directory.

@cindex Architectural Overview
@heading Architectural Overview

@image{img/overview}

This is the great overview of the planned structure of OpenDarkEngine. Some services might be missing in the diagram,
and the diagram will probably develop as the project gets further. Still this gives a rough view of what the engine will be build
of, and which categories of services exist. Each service in this picture is a standalone unit that targets a different task.

@cindex Core classes
@heading Core classes

These are the core classes used:
@table @asis
@item Opde::Root
	A central class for the engine. Manages the engines lifetime.
@item Opde::ServiceManager
	Manages the Service objects.
@item Opde::Service
	Subclasses of which fulfil various purposes (Graphics, AI, Sound, Physics, Object System, etc.)
@end table

@cindex Opde::Root
@heading Root object
Is a bed for the whole engine. Exposes various initialization methods, logging methods. Whole engine is constructed
and initialized using this class.

@cindex ServiceManager
@heading ServiceManager

@image{img/service}

As the name of it suggests, this class is used to hold services and manage them. Each subclass of the Service class has a
Factory class instance registered here (Opde::Root object does this). ServiceManager is a singleton class, meaning it only
ever has one instance per application.

Service manager also manages the bootstrap/main lifetime stages of the engine existence.

For convenience, a @i{GET_SERVICE(ClassName)} macro exists, which gets the service instance and casts it to shared_ptr of the specified
type. Example:

@verbatim
RenderServicePtr rs = GET_SERVICE(RenderService);
@end verbatim

Services, thanks to the shared_ptr, get destroyed once no reference points to them. One of the references is stored in the ServiceManager. 
Normally, it is not needed to take special care about the Service reference count, but in some special cases, if the Service reference
needs to be disposed to release the service (for example circular references between Services, or external usage of the Service), setting
NULL to the service's shared_ptr is needed:

@verbatim
// prev. allocation
RenderServicePtr rs = GET_SERVICE(RenderService);
// some code
rs->someMethod();
// release the service 
rs->setNull();
// or rs = NULL;
@end verbatim

This operation is needed in the following situations:

@itemize @bullet
@item
Circular reference between services - then the reference has to be released in the shutdown method of at least one of the services.
@item
External usage of the service - in this situation the service's reference has to be released before the ServiceManager (or Root object) is destroyed.
@end itemize

@cindex Service
@heading Service
The whole engine is built around a modular concept of Services. Services are autonomous classes (or sets of classes) that serve different 
purposes. All service instances are managed using a ServiceManager object. Each of the service's instance exists only 
once within ServiceManager's ownership. Services reference, use each other. For this to work well, shared pointers are
used to reference services. 

Each of the services has a name and service mask. Name is used to reference the service, mask is used to automate some common
tasks, and to mask the instantinated services, as requested via the parameter to the Opde::Root constructor. The service mask
also enables one to construct, for example, only the core object system of the engine, meaning no graphical output, no simulation
is done. This is especially usable for tool makers.

All services are constructed using Service Factories, which are registered by either client code or Opde::Root object
within the bootstrapping phase of the engine.

There are three stages of service's life time:

@cindex Service lifetime phases
@table @asis
@item Bootstrap phase
	Which is used to setup resources for the services and initialize service's dependencies. 
	This phase is active when the engine is bootstrapping.
@item Main lifetime
	Which represents the phase of the lifetime service is fully usable.
@item Shutdown
	Which is used to break circular references between services and release all the resources service holds.
@end table

All services are guaranteed to be bootstrapped and shut down under the condition of a normal application flow.

@cindex Service masks
@heading Service Masks
Now you might wonder what the service masks are, and what are they used for? It's quite easy. Every registered Service Factory there
is exposes a method to get the service mask for the given service. The service mask is freely used unsigned integer, which is compared
with the specified mask that the service manager was constructed/initialized with. Nonzero bitwise and product will mean the service
should be constructed and used.
What's that good for? The engine can be told to be initialized and exist only with a subgroup of the available services. With SERVICE_CORE
flags for example, the engine only initializes the services which are cruical to the engine - database and object services (together with some
other core services - as for example the Config service).
To learn more, look inside the src/services/serviceCommon.h file.

@c --------------------------------------------------------------------
@node Services
@chapter Services
@cindex Services

This is the current list of available engines services:

@table @asis
@item @ref{Binary Service}
	Is a helper service that holds dynamically defined types and enumerations, as specified by, for example the dtdef scripts.
@item @ref{Database Service}
	Is a game database loading/saving service. Manages the loading/saving of .GAM/.MIS/.SAV files. All the services which store some
	data inside these files listen to the events that this service generates and act accordingly.
@item @ref{Object Service}
	Is the main service for the engine's object system. Manages game object's lifetime.
@item @ref{Link Service}
	Is the link management service. Stores Relation objects. Each relation object stores all links of particular flavor.
@item @ref{Property Service}
	Is the property manager. Properties are named "types" that object can carry. Each of the property types has one PropertyGroup instance held by this service.
@item @ref{Inherit Service}
	This service manages object @i{trait} inheritance. Currently is used to cache and propagate inherited properties for objects.
@item @ref{WorldRep Service}
	This service is responsible for loading and preparing the World Rep, which is a different name for the level geometry. It loads and prepares it for display.
@item @ref{Light Service}
	This service manages lights in the world
@item @ref{Material Service}
	Helper service that helps with game object materials (textures, etc).
@item @ref{Render Service}
	This service manages the display of the engine.
@item Input Service
	Service that manages keyboard and mouse inputs and their translation to commands.
@item Script Service
	Script interfacing service. Manages loading/unloading of script modules, script instantization and event translation.
@end table

@c --------------------------------------------------------------------
@node Binary Service
@section Binary Service
@cindex Binary Service

@image{img/binarysvc}

This service stores dynamically defined structures and enumerations. These are defined via .dtype scripts, which have a simple, C-like syntax:

@cindex dtype script
@verbatim
// a comment

// Bitfield - maps bits of a unsigned, 32 bit integer to string names. A special case of enumeration
bitfield bitf {
	key "bit one" 0x01
	key "bit two" 0x02
}

// Enumeration - much like the C enumerations. Maps different unique values of the specified type to string name
enum enumeration : uint {
	key "Option A" 0x00
	key "Option B" 0x01
}

// A sample, nested struct 
struct str {
	uint32 use bitf uint_with_bitfield
	int16 array [3]
	
	// an array of four structs
	struct test [4] {
		float x
		char [4] name
	}
}

// an alias - like C++ typedef
alias str str2

// a namespace. Can't be nested, default namespace is ""
namespace Test {
}
@end verbatim

These scripts are parsed using the DTypeScriptCompiler class and compiled into DType objects, then registered in the binary service.
As a result, the binary service registers all the dynamically defined data types, which can then be used to load data that are not
yet handled effectively using some other approaches.

@c --------------------------------------------------------------------
@node Database Service
@section Database Service
@cindex Database Service

@image{img/databasesvc}

This service is responsible for game state handling. It can load and unload mission files, gamesys files, savegames, etc. and also save 
them. It also exposes two types of messages, one is used to load or save data, the other is used to display loading/saving status.

The service is currently a placeholder for a more propper implementation, but works well for the loading part.

@cindex Tag File Database
@subheading Tag File Database
This service handles the Tag File Databases (also known as Dark Database). Those are files that contain tag files (also sometimes called chunks).
Each of them has a name (much like a file name) and a version. The positions and lengths of those chunks is stored at the end of the file. 
See FileGroup.h/.cpp for more info.
The tag file databases have typically extensions .mis, .gam or .sav (among others).

@c --------------------------------------------------------------------
@node Object Service
@section Object Service
@cindex Object Service

@image{img/objsvc}

@cindex Object System
@heading Object System
The core of the engine is the object system. Object system in Dark Engine is quite different from what one would probably expect. There is no 
object instance for objects one sees/uses, the game objects are just integer IDs that represent them. Everything the objects are consisted of 
is stored as Property or link with the particular integer ID.

@cindex Object types
@cindex Archetype objects
@cindex Concrete objects
@subheading Object types
There are two object types. Concrete objects and Archetype Objects. The Archetype objects (also called archetypes) are not live objects,
but more template objects that serve as default value holders for properties and links. Archetypes typically have ID less than zero, and always bear DonorType property.
The concrete objects are instances of the archetype objects, optionally. It is very common for concrete objects to inherit from an archetype. 

There are a few archetype object types. Archetypes also inherit from each other, so there is what one could imagine as a set of trees with a root 
object for every archetype type. Metaproperty archetype object tree needs a special attention. All the objects in that tree bear a different
DonorType property value than the other archetypes, and when inherited, bear a different (non-zero) MetaProperty link priority value.
The inheritance mechanisms are more explained later in the @ref{Inherit Service} section.

Relations and Properies both utilise DataStorage class as a data storage backend (every object or link id can have data stored inside).

@cindex DonorType
@subheading DonorType Property
DonorType is a property that is only owned by archetype objects. It indicates if the object is an archetype or metaproperty.

@cindex SymbolicName
@subheading SymbolicName Property
SymbolicName is a property that is never inherited and contains object-system wide unique string name of the object.

@cindex Position
@subheading Position Property
Position property contains position in space, orientation in space and some other useful position-related fields. Is only valid for concrete objects, has
no meaning on archetypes.

@c --------------------------------------------------------------------
@node Link Service
@section Link Service
@cindex Link Service

@image{img/linksvc}

@cindex Link
@cindex Links
@subheading Links

Links are connections between objects. They have different types (called flavors). Each of the link flavors has different (if any - it's optional) data format attached and is managed
with a different, separate Relation class. Relation instances come in pairs. This is meant to allow the usage of LinkFlavor, ~LinkFlavor pairs.

Links have source object ID, destination object ID, flavor and link ID. Link ID is composed of three parts - Concreteness, Flavor and serial ID.

@cindex Flavor
@subheading Link Flavor
Link flavor is a unique link type identifier. It comes as string (MetaProp, Contains, etc.) and ID (1/-1, 5/-5). The integer ID of the flavor is determined as the index of the flavor name in the 
table stored in a chunk named "Relations". This mapping happens dynamically upon gamesys or mission load. 

@cindex Relation
@subheading Relation
Relation class is the heart of the link service. It stores all links of a particular link type. It is capable of disk loading/saving, queries, etc. Relations are indexed by flavor name and 
flavor ID. Relation names starting with '~' sign are inverse relations. Those have negative flavor id and contain links in the opposite direction (compared to normal relation of the same flavor).

@c --------------------------------------------------------------------
@node Property Service
@section Property Service
@cindex Property Service

@image{img/propsvc}

@cindex property
@cindex Properties
@subheading Properties
Properties are values or sets of values, that can be assigned to objects. Each object either holds a certain property type or doesn't.
Properties come in different types, and serve different purposes. Each of those types has a different name which identifies it.

Some properties are inherited (Others, like DonorType, are not). That means that if a given object does not own a value of the certain property, it still can have some inherited
from an archetype object (Object types). If object owns the property, any inherited values are typically masked, the priority of owned property is greater than the inherited one.

Property service manages all object properties. Each of the property types has it's own PropertyGroup instance, or is constructed via code of the particular service which handles the
property. Thus, we have SymbolicName and DonorType properties statically created in @ref{Object Service}, RenderType or RenderAlpha (and others) in @ref{Render Service}, etc.
Properties can be implemented effectively, without the use of the DataStorage instance, or with it.

@cindex effective object ID
PropertyGroup instances typically use a Inheritor instance - it is used to determine effective object ID. This id is the id of the bearer of the effective (active) property for the object ID.
Example:

@image{img/propinh}


In this rather unrealistic and dull example, the SomeProperty has a value '2' on "A Chair" object, as it is inherited from the archetype object "Chair" (object ID -125). Property OtherProperty masks the value from
object Furniture, and thus the "A Chair" has OtherProperty = 4.
@c --------------------------------------------------------------------
@node Inherit Service
@section Inherit Service
@cindex Inherit Service

@image{img/inheritsvc}

@cindex trait
This service handles the MetaProp link. Contains named factories for different @i{trait} (some kind of object's quality - for example property ownership) inheritance schemes. Current list is (Inheritor factory names):
@itemize @bullet
@item
	Always - Always inherits traits from archetypes
@item
	Archetype - Only inherits values on archetypes, so instances of objects need to gain a copy of the property value (used for properties that need a special care - physics, anim lights for example)
@item
	Never - This inheritor never inherits - it is used for things which are unique to both archetypes and concretes (Symbolic Name, donor type).
@end itemize

@cindex MetaProperty
@subheading MetaProperty
MetaProp link carries one unsigned integer as data (priority). If the value of it is zero, the link implements archetype inheritance. Nonzero links are MetaProperty links, and each of them has different priority. 
The property, if not carried by the inheriting object itself, is inherited from the metaproperty source with the highest priority that offers it. Only one link of each priority value is allowed per object.
Metaproperty object links have priority 1024 or higher. 

Metaproperty objects bear different DonorType property value than other archetype objects.

@c --------------------------------------------------------------------
@node WorldRep Service
@section WorldRep Service
@cindex WorldRep Service

@image{img/worldrepsvc}

This service is responsible for loading WR/WRRGB tag files. These contain the static level geometry, which is traditionally called terrain. It does this in cooperation with 
@ref{Light Service}, @ref{Material Service} and DarkSceneManager.

@cindex WR
@cindex WRRGB
@heading WR/WRRGB - a short introduction

@subheading Some facts
In the times the Dark Engine was written, the pixels were expensive. WorldRep format is thus designed with that in mind. First, a few characteristic points about it:
@itemize @bullet
@item
	Uses BSP tree - and it did so for two reasons: sorting rendered geometry and BSP traversal for point in cell searches
@item
	Contains Cells - these are convex, irregular polyhedra, with some faces textured. Others are just portals to other cells (can be either face, portal, or both in case of water)
@item
	Uses Portals - the old kind of those - these are polygons that connect two cells. Portals in WR are unidirectional
@item
	Uses Light Maps - the idea Quake 1 came with - pre-computed textures that modulate the intensity of textures applied on faces. The software version of Dark Engine renderer used surface cache
@item
	Does not contain precomputed PVS (Potential visibility sets). Visible cells are computed dynamically as needed.
@end itemize

@cindex PVS
@subheading Visibility Determination (Dynamic PVS)
Visibility determination is a process that determines the visible cell set from the given point and direction in space. As the portal counts in typical scenes go up to thousands,
frustum culling is not usable for visibility determination. Instead, the portal (which is a polygon) is projected to screen space, vertex after vertex. The resulting screen coordinates
define bounding box which is then clipped against previous bounding boxes. The result is see-through screen space rectangle that determines the maximal visible area the portal gives in 
the defined circumstances. Thanks to the fact there can be more than one cell-portal path to see a given portal, the particular rectangles for the given polygon are unioned (well, in fact, 
this is done per cell, not per polygon, but that is rather minor difference).
The traversal is done in breadth-first manner, so the retraversals that are caused by visibility re-evaluations are minimised.

@cindex Rendering
@subheading Our current rendering approach
As the technology advanced, the pixels become cheap, but the draw calls became expensive. Thus, we introduce a few optimizations, not necesarilly the best and most clever ones,
that allow rendering the WR geometry on modern hardware using modern approaches.

@itemize @bullet
@item
	VBO usage - we dynamically fill the index buffers of VBO object according to the cell lists. The mapping cell -> index set and rendering is done in the DarkGeometry class
@item
	Texture atlas usage - we use texture atlasses for lightmaps. They are built as the level is loaded, and use BSP tree to place the lightmap. This minimizes the batch counts
@item
	Conversion of dynamic lights to standard lights - we will need to do this. Original Dark Engine computes low-resolution lightmaps for all affected surfaces of dynamic lights. 
	We will use standard lights instead for the purpose of dynamic lighting.
@end itemize

@c --------------------------------------------------------------------
@node Light Service
@section Light Service
@cindex Light Service

@image{img/lightsvc}

Dark Engine introduces a pre-baked list of lights (built upon portalisation) in the WR tag file, right after the end of the BSP tree. This service handles the lights.
The loading of the light list is invoked by WorldRep service when loading WorldRep. This service also handles lightmaps using atlases, and is capable of individual light
modulation.
Later, this service will also be capable of light related tweqs in cooperation with Tweq service and anim light handling, and dynamic light handling (dynamic lights
are the only ones which influence the lighting of the static geometry in realtime).

@c --------------------------------------------------------------------
@node Material Service
@section Material Service
@cindex Material Service

@image{img/materialsvc}

Manages all the materials for static geometry, models and AI. Later it will also manage material properties and material overrides.

@c --------------------------------------------------------------------
@node Render Service
@section Render Service
@cindex Render Service

This service is a connection point between Ogre and Opde. It manages display (resolution etc) and model rendering.

@c --------------------------------------------------------------------
@node Index
@unnumbered Index
   
@printindex cp
     
@bye
